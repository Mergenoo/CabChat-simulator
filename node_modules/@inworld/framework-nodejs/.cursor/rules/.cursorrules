# Project Type: Node.js Wrapper Library over Inworld framework cpp (marketing name is: Inworld Framework NodeJS SDK)
This project is a Node.js/TypeScript wrapper over the Inworld C++ Framework.

# Framework Structure
## Core Components (src/)
- Device Management: DeviceRegistry, Device, DeviceType (CPU/CUDA/Metal)
- Text Processing: SentenceStream, TextProcessing, EmojiRemover, TextInBracketsRemover
- History Management: Event handling and vector operations
- Error Handling: InworldError
- Audio Processing: AudioChunk handling

## C++ Framework Components (library/)
- Local Agent STS: Agent implementation and LLM wrapper
- Local Models: Custom model implementations and embeddings
- Remote Services: Embedder and knowledge base integrations
- Speech Processing: STT and TTS implementations
- Natural Language: NER and goal detection
- Knowledge Management: Local and remote knowledge bases

## Primitives (src/primitives/)
- LLM: Text generation and Jinja template rendering (local/remote modes)
- STT: Speech-to-text conversion with configurable models
- TTS: Text-to-speech with configurable synthesis and preprocessing
- Embedder: Text embedding functionality with local/remote support
- Knowledge: Knowledge collection and retrieval with configurable thresholds
- Memory: Memory management, snapshots, and rolling summaries
- Safety: Content safety checking
- Intent: Intent compilation and matching
- NER: Named Entity Recognition

# Code Reuse
- When implementing new functionality, always search the `src` folder first for existing:
  * Types, interfaces, and enums
  * Utility classes and helper functions
  * Error handling patterns
  * Factory implementations
  * Configuration structures
- Use the existing patterns and classes when possible to maintain consistency
- Import from common modules rather than duplicating functionality
- Check related primitives for similar implementations that can be adapted
- Review existing tests to understand how similar components are used and tested
- Pay special attention to resource management patterns for native objects

# Core Dependencies
- Platform-specific C++ binaries (libinworld.so/inworld.dll/libinworld.dylib)
- koffi for native bindings
- Node.js >= 18.0.0
- System dependencies:
  * BLAS for numerical computations
  * iconv for character encoding
  * fontconfig for text rendering
  * ONNX Runtime for ML models
  * CUDA/Metal for GPU acceleration

# Knowledge Management
## Knowledge ID Format
- Knowledge IDs must always start with the 'knowledge/' prefix
- Example: 'knowledge/my-collection' or 'knowledge/user-docs'
- This prefix is required by the underlying C++ implementation
- Using IDs without this prefix will result in failed retrieval
- Always validate that knowledge IDs conform to this format
- This requirement applies to all knowledge operations:
  * compileKnowledge
  * getKnowledge
  * removeKnowledge

# Environment Setup
- Git LFS required for binary files
- Local models stored in ./data directory
- Environment variables for API keys and configuration
- Docker support for development and testing
- Model files:
  * test-vad.onnx for voice activity detection
  * test-asr.bin for speech recognition
  * test.gguf for local LLM inference
  * model_weights.json for content safety checking

# Templates Structure
## Character Engine Application
- Server: Express.js server handling LLM, STT, TTS services
- Client: React-based UI with Material-UI components
- WebSocket communication for real-time interaction
- Demonstrates full integration of all primitives

## Primitive Templates
- Basic LLM usage (local/remote modes)
- Basic STT implementation with configurable models
- Basic TTS implementation with synthesis config
- Memory and Knowledge base usage with embeddings
- Embedder functionality for text similarity
- Template chatbot implementation
- Intent matching and compilation

# Common Pitfalls
- Missing system-level dependencies (BLAS, iconv, fontconfig)
- Incorrect binary for platform (Linux/Windows/MacOS)
- Not using Git LFS when cloning
- Attempting to use without required local models
- Not properly destroying resources (memory leaks)
- Incorrect model paths or configurations
- Missing API keys for remote services
- GPU acceleration issues on unsupported platforms
- ONNX model loading failures
- Missing or incorrect safety model configuration
- Incomplete workflow updates when adding new model dependencies

# Development Notes
- All core functionality is in C++ framework
- Node.js code provides TypeScript types and bindings
- Each primitive has its own factory pattern implementation
- Resource management requires explicit destroy() calls
- Templates demonstrate wrapper usage, not core implementation
- Package distribution includes both JS package and C++ binaries
- Docker support for consistent development environment
- Comprehensive test suite with Jest
- Unit tests are mandatory and must be placed in `__tests__` folder
- Tests can be executed from root using `yarn test`
- C++ framework uses Bazel for building
- Local models require specific formats and configurations

# Context Management (.context/)
## Purpose
- Stores additional context for Cursor IDE
- Contains references to related codebases
- Helps maintain project knowledge
- Improves code navigation and understanding

  
## Context File Format
- Use clear section headers with '---' separators
- Include file paths with line numbers for references
- Add brief explanations for included code segments
- Keep individual files under 2MB for better performance
- Include relevant environment variables and configurations
- Document model requirements and specifications
- Include GPU acceleration requirements

## Example Format:
```txt
--- Component: LLM Bindings ---
Source: src/primitives/llm/llm.ts:16-63
Purpose: Main LLM interface implementation
Key Dependencies: koffi, C++ LLM interface
Environment Variables: INWORLD_LLM_API_KEY, INWORLD_LLM_MODEL_NAME
Model Requirements: test.gguf for local inference
GPU Support: CUDA/Metal acceleration available

[Code snippet or reference]

--- Related Files ---
- src/expose_binary.ts: Binary loading
- templates/ts/cli/primitives/basic_llm.ts: Usage example
- src/primitives/llm/config.ts: Configuration options
- library/llm_wrapper.cc: C++ implementation
```

## Best Practices
- Update context files when making significant changes
- Focus on architectural decisions and key implementations
- Include links to external documentation when relevant
- Use semantic grouping rather than alphabetical ordering
- Reference specific commit hashes for C++ framework versions
- Document environment variables and their purposes
- Include troubleshooting steps for common issues
- Document model compatibility and requirements
- Include GPU acceleration guidelines

## Performance Considerations
- Split files larger than 2MB into logical components
- Use relative paths for better portability
- Consider using symbolic links for shared context
- Implement versioning for context files (e.g., v1, v2)
- Cache frequently accessed context segments
- Optimize binary loading and resource management
- Consider GPU memory management
- Profile model inference performance

## Integration with Cursor
- Place .context/ in project root
- Add to .gitignore if context is developer-specific
- Consider sharing via separate context repository
- Use consistent naming conventions across projects
- Include platform-specific considerations
- Document Docker setup and requirements
- Include GPU acceleration setup instructions

## Testing and Quality Assurance
- Unit tests are mandatory for all new code
- Unit tests must be placed in the `__tests__` folder
- Unit tests can be run from the root folder using `yarn test`
- When adding new environment variables or configuration options:
  * Update all platform-specific workflow files:
    - `.github/workflows/test-linux.yml`
    - `.github/workflows/test-macos.yaml`
    - `.github/workflows/test-windows.yml`
  * Update the `fetch_models` action in `.github/actions/fetch_models/action.yml`
  * Ensure the new variables are properly passed to the fetch models step
- Unit tests for each primitive
- Integration tests for example applications
- Performance benchmarks for critical paths
- Memory leak detection and prevention
- Platform compatibility testing
- Documentation testing and verification
- GPU acceleration testing
- Model inference accuracy testing
- Refer to existing env variables for testing:
    TEST_INWORLD_API_KEY
    TEST_LLM_MODEL_NAME
    TEST_LLM_MODEL_PATH
    TEST_EMBEDDER_MODEL_PATH
    TEST_STT_MODEL_PATH
    TEST_TTS_MODEL_PATH
    TEST_TTS_PROMPTS_PATH
    TEST_SAFETY_MODEL_PATH
    TEST_VAD_MODEL_PATH

## Code Formatting
- Always run Prettier after making changes using `yarn prettier`
- Prettier configuration is in `.prettierrc.json`
- Format all JavaScript, TypeScript, JSX, and TSX files
- Ignore files listed in `.gitignore`
- Run formatting from project root directory

## Security Considerations
- API key management and rotation
- Secure storage of sensitive configurations
- Input validation and sanitization
- Resource access control
- Error handling and logging
- Secure communication protocols
- Model security and integrity checks
- GPU memory isolation

# Cross-project git source dependencies
All interrelated repositories descriptions located at .cursor/rules/git-sources.mdc;

## Lastly
Always suggest improvements to these rules if you see how they can be improved.

Thank you! (In case of machine uprising)

# Koffi Type Handling
- Be aware of `koffi` errors like `TypeError: Cannot pass ambiguous value to void *, use koffi.as()`. This typically occurs when a JavaScript type (e.g., an array) is passed to a native function expecting a pointer (e.g., `void *`).
- To resolve this, explicitly create the corresponding native structure (e.g., a native vector) using the appropriate functions exported from `src/expose_binary.ts` (e.g., `VectorTopicThresholdFunctions.new()`).
- Populate the native structure using its exported functions (e.g., `VectorTopicThresholdFunctions.pushBack()`) before passing its pointer to the native function that requires it.

# Native Object Lifecycles
- Native objects created via `koffi` require careful lifecycle management to prevent memory leaks or double-free errors.
- When passing native object handles (pointers) to other native functions that take ownership, do *not* manually delete the original handle for the owned object. The owner function is now responsible for its cleanup.
- Example Pattern (e.g., `createNativeSafetyConfig`):
  1. Create temporary native objects/vectors needed for construction (e.g., `VectorTopicThresholdFunctions.new()`).
  2. Keep track of created temporary handles (e.g., in a `createdThresholds` array).
  3. Populate the temporary structures.
  4. Call the native function that takes ownership, passing the pointer(s) to the temporary structures (e.g., `SafetyConfigFunctions.setForbiddenTopics(nativeConfig, nativeTopicsVector)`).
  5. If the ownership transfer call succeeds, clear the tracking array (`createdThresholds.length = 0;`) for objects whose ownership was transferred.
  6. In a `finally` block, *always* delete the handles for temporary *container* structures (like `nativeTopicsVector`) that were used but whose ownership wasn't transferred.
  7. In case of an error *before* ownership transfer, ensure all individually created temporary handles (those still in `createdThresholds`) and the main object being constructed (`nativeConfig`) are deleted.

# Native Error Handling
- When catching errors from native function calls (`try...catch`):
  - Check if the error is a standard JavaScript `Error` using `err instanceof Error`.
  - If true, use `err.message`.
  - If false, assume it's a native `Status` object pointer.
  - Use `StatusFunctions.toString(err)` (ensure `StatusFunctions` is imported from `expose_binary.ts`) to get a string representation of the native error.
  - Wrap the resulting message in an `InworldError` for consistent error reporting.

# Exposing Native Functions
- Not all C++ functions defined in the native library (and visible in `bin/inworld.h`) are necessarily exported via `src/expose_binary.ts`.
- If you need a native function (especially for vector creation/manipulation like `inworld_vector_..._new`, `_push_back`, `_delete`) that isn't exported, check `bin/inworld.h` for the exact C function name.
- Add the necessary `koffi.func` mapping to `src/expose_binary.ts` under an appropriate exported const (e.g., `VectorTopicThresholdFunctions`).

# Promisified C++ Function Results
- When using `util.promisify()` on Koffi functions that return StatusOr objects:
  * Do NOT attempt to delete/free the result object directly (e.g., `StatusFunctions.delete(result)`)
  * These objects are already managed by the C++ runtime
  * Only call `.delete()` on objects explicitly created in JavaScript code
  * Memory ownership principle: Only clean up objects that you explicitly created
  * Example of correct usage:
  ```typescript
  // CORRECT:
  const result = await PromisifiedFunction(...);
  if (!StatusFunctions.isOK(result)) {
    const status = StatusFunctions.getStatus(result);
    throw new InworldError(`Failed: ${status}`);
  }
  const value = StatusFunctions.getValue(result);
  return value;
  
  // INCORRECT - will cause "TypeError: Unexpected Object value, expected void *":
  const result = await PromisifiedFunction(...);
  if (!StatusFunctions.isOK(result)) {
    const status = StatusFunctions.getStatus(result);
    StatusFunctions.delete(result); // DON'T DO THIS
    throw new InworldError(`Failed: ${status}`);
  }
  const value = StatusFunctions.getValue(result);
  StatusFunctions.delete(result); // DON'T DO THIS
  return value;
  ```
- This pattern applies to all result objects from promisified Koffi functions:
  * LLMInterfaceFunctions
  * TextEmbedderInterfaceFunctions
  * KnowledgeStatusFunctions
  * KnowledgeVectorStatusFunctions
  * And other similar StatusOr object results

# Status Error Handling
- When handling errors from native function calls with status objects:
  * Use the `getStatusContext` helper from `common/helpers.ts` for consistent error handling
  * Pass getStatusContext(status) directly as the second parameter to InworldError
  * Pattern to follow:
  ```typescript
  // CORRECT:
  if (!SomeFunctions.isOK(result)) {
    const status = SomeFunctions.getStatus(result);
    throw new InworldError('Failed to do operation', getStatusContext(status));
  }
  
  // INCORRECT:
  if (!SomeFunctions.isOK(result)) {
    const status = SomeFunctions.getStatus(result);
    throw new InworldError(`Failed to do operation: ${status}`);
  }
  
  // ALSO INCORRECT (unnecessarily wrapping in an object):
  if (!SomeFunctions.isOK(result)) {
    const status = SomeFunctions.getStatus(result);
    throw new InworldError('Failed to do operation', { 
      status: getStatusContext(status) 
    });
  }
  ```
- The `getStatusContext` helper ensures:
  * Consistent error message formatting
  * Proper extraction of status information
  * Safe handling of status objects
  * Support for structured error information in logs


