"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Memory = void 0;
const common_1 = require("../../common");
const expose_binary_1 = require("../../expose_binary");
const memory_snapshot_1 = require("./memory_snapshot");
/**
 * Class for managing conversational memory in agents.
 * Provides functionality to retrieve and update memory based on conversation history.
 */
class Memory {
    /**
     * Creates a new Memory instance.
     *
     * @param memory - External reference to the native memory implementation
     * @param factory - External reference to the factory that created this memory
     * @internal
     */
    constructor(memory, factory) {
        this.memory = memory;
        this.factory = factory;
    }
    /**
     * Retrieves memory content based on conversation history.
     *
     * @param history - Conversation history to retrieve memory from
     * @param memorySnapshot - Current memory snapshot
     * @returns Promise resolving to array of memory strings
     */
    get(history, memorySnapshot) {
        return __awaiter(this, void 0, void 0, function* () {
            let vector;
            let status;
            let result;
            try {
                status = yield expose_binary_1.MemoryInterfaceFunctions.getMemory(this.memory, history.getExternal(), memorySnapshot.getExternal());
                const value = expose_binary_1.StatusOrVectorStringFunctions.getValue(status);
                result = common_1.VectorString.toArray(value);
            }
            finally {
                vector === null || vector === void 0 ? void 0 : vector.destroy();
                expose_binary_1.StatusOrVectorStringFunctions.delete(status);
            }
            return result;
        });
    }
    /**
     * Updates memory content based on conversation history.
     *
     * @param history - Conversation history to update memory with
     * @param memorySnapshot - Current memory snapshot to update
     * @returns Promise resolving to new memory snapshot
     */
    update(history, memorySnapshot) {
        return __awaiter(this, void 0, void 0, function* () {
            let status;
            let newMemorySnapshot;
            try {
                status = yield expose_binary_1.MemoryInterfaceFunctions.updateMemory(this.memory, history.getExternal(), memorySnapshot.getExternal());
                const value = expose_binary_1.StatusOrMemorySnapshotFunctions.getValue(status);
                newMemorySnapshot = new memory_snapshot_1.MemorySnapshot({ external: value });
            }
            finally {
                expose_binary_1.StatusOrMemorySnapshotFunctions.delete(status);
            }
            return newMemorySnapshot;
        });
    }
    /**
     * Cleans up resources associated with this memory instance.
     */
    destroy() {
        if (this.memory) {
            expose_binary_1.MemoryInterfaceFunctions.delete(this.memory);
            this.memory = null;
        }
        if (this.factory) {
            expose_binary_1.MemoryFactoryFunctions.delete(this.factory);
            this.factory = null;
        }
    }
}
exports.Memory = Memory;
