"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryFactory = void 0;
const error_1 = require("../../common/error");
const helpers_1 = require("../../common/helpers");
const expose_binary_1 = require("../../expose_binary");
const retrieval_config_1 = require("../knowledge/retrieval_config");
const flash_memory_config_1 = require("./flash_memory_config");
const long_term_memory_config_1 = require("./long_term_memory_config");
const memory_1 = require("./memory");
const rolling_summary_config_1 = require("./rolling_summary_config");
/**
 * Factory class for creating Memory instances.
 * Provides functionality to create and configure different types of memory.
 */
class MemoryFactory {
    /**
     * Creates a new Memory instance.
     *
     * @param params - Parameters for memory creation including different memory types
     * @returns Promise resolving to a new Memory instance
     * @throws InworldError if memory creation fails
     */
    createMemory(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let rollingSummary;
            let flashMemory;
            let longTermMemory;
            let retrievalConfig;
            let status;
            let factory;
            try {
                factory = expose_binary_1.MemoryFactoryFunctions.new();
                rollingSummary = new rolling_summary_config_1.RollingSummaryConfig(params.rollingSummary);
                flashMemory = new flash_memory_config_1.FlashMemoryConfig(params.flashMemory);
                longTermMemory = new long_term_memory_config_1.LongTermMemoryConfig(params.longTermMemory);
                retrievalConfig = new retrieval_config_1.RetrievalConfig((_a = params.retrievalConfig) !== null && _a !== void 0 ? _a : {});
                status = yield expose_binary_1.MemoryFactoryFunctions.createMemory(factory, params.llm.getExternal(), params.embedder.getExternal(), rollingSummary.getExternal(), flashMemory.getExternal(), longTermMemory.getExternal(), retrievalConfig.getExternal(), (_b = params.returnRollingSummary) !== null && _b !== void 0 ? _b : false);
                if (!expose_binary_1.StatusOrMemoryInterfaceFunctions.isOK(status)) {
                    throw new error_1.InworldError('Failed to create memory interface', (0, helpers_1.getStatus)(status));
                }
                const value = expose_binary_1.StatusOrMemoryInterfaceFunctions.getValue(status);
                return new memory_1.Memory(value, factory);
            }
            finally {
                rollingSummary === null || rollingSummary === void 0 ? void 0 : rollingSummary.destroy();
                flashMemory === null || flashMemory === void 0 ? void 0 : flashMemory.destroy();
                longTermMemory === null || longTermMemory === void 0 ? void 0 : longTermMemory.destroy();
                retrievalConfig === null || retrievalConfig === void 0 ? void 0 : retrievalConfig.destroy();
                if (status) {
                    expose_binary_1.StatusOrMemoryInterfaceFunctions.delete(status);
                }
            }
        });
    }
}
exports.MemoryFactory = MemoryFactory;
