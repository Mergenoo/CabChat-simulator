"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TTS = void 0;
const common_1 = require("../../common");
const helpers_1 = require("../../common/helpers");
const expose_binary_1 = require("../../expose_binary");
/**
 * Class for text-to-speech processing.
 * Provides functionality to convert text into synthesized speech audio.
 */
class TTS {
    /**
     * Creates a new TTS instance.
     *
     * @param tts - External reference to the native TTS implementation
     * @internal
     */
    constructor(tts) {
        this.tts = tts;
    }
    /**
     * Returns the external reference to the native TTS implementation.
     *
     * @returns External reference object
     * @internal
     */
    getExternal() {
        return this.tts;
    }
    /**
     * Synthesizes speech from text using a specified voice.
     *
     * @param speakerId - ID of the speaker/voice to use for synthesis
     * @param text - Text to convert to speech
     * @returns A stream iterator for the synthesized audio chunks
     * @throws InworldError if speech synthesis fails
     */
    synthesizeSpeech(speakerId, text) {
        return __awaiter(this, void 0, void 0, function* () {
            let voice = null;
            let iterator;
            try {
                // Create and configure the Voice object
                voice = new common_1.Voice(speakerId);
                // Call the synthesizeSpeech function
                const ttsStreamStatus = yield expose_binary_1.TTSInterfaceFunctions.synthesizeSpeech(this.tts, voice.getExternal(), text);
                const inputStream = expose_binary_1.SpeechChunkInputStreamFunctions.getStream(ttsStreamStatus);
                iterator = this.streamIterator(ttsStreamStatus, inputStream);
            }
            finally {
                if (voice) {
                    voice.destroy();
                }
            }
            return iterator;
        });
    }
    /**
     * Creates a stream iterator for processing synthesized speech chunks.
     *
     * @param statusOrInputStreamSpeechChunk - Status of the speech synthesis
     * @param inputStream - Input stream containing speech chunks
     * @returns Stream iterator for accessing audio chunks
     * @private
     */
    streamIterator(statusOrInputStreamSpeechChunk, inputStream) {
        const self = this;
        return {
            next: function () {
                return __awaiter(this, void 0, void 0, function* () {
                    while (expose_binary_1.SpeechChunkInputStreamFunctions.hasNext(inputStream)) {
                        const chunkStatus = yield expose_binary_1.SpeechChunkInputStreamFunctions.read(inputStream);
                        if (!expose_binary_1.SpeechChunkStatusFunctions.isOK(chunkStatus)) {
                            throw new common_1.InworldError('Failed to read speech chunk', (0, helpers_1.getStatus)(chunkStatus));
                        }
                        // Get the chunk
                        const chunk = expose_binary_1.SpeechChunkStatusFunctions.getValue(chunkStatus);
                        try {
                            // Get the waveform
                            const waveformPtr = expose_binary_1.SpeechChunkFunctions.getWaveform(chunk);
                            // Convert the waveform to a Float32Array
                            const audio = common_1.VectorFloat.toArray(waveformPtr);
                            // Get phoneme timestamps if available
                            let phonemeTimestamps = self.getPhonemeTimestamps(chunk) || [];
                            // return chunk
                            return { done: false, audio, phonemeTimestamps };
                        }
                        finally {
                            // Clean up the chunk
                            expose_binary_1.SpeechChunkFunctions.delete(chunk);
                        }
                    }
                    expose_binary_1.SpeechChunkInputStreamFunctions.delete(statusOrInputStreamSpeechChunk);
                    return { done: true };
                });
            },
        };
    }
    /**
     * Extracts phoneme timestamps from a speech chunk.
     *
     * @param chunk - Speech chunk to extract phoneme timestamps from
     * @returns Array of phoneme timestamps or undefined if not available
     * @private
     */
    getPhonemeTimestamps(chunk) {
        const phonemeTimestampsVector = expose_binary_1.SpeechChunkFunctions.getPhonemeTimestamps(chunk);
        let phonemeTimestamps = undefined;
        if (phonemeTimestampsVector) {
            const vectorSize = expose_binary_1.PhonemeTimestampVectorFunctions.size(phonemeTimestampsVector);
            if (vectorSize > 0) {
                phonemeTimestamps = [];
                for (let i = 0; i < vectorSize; i++) {
                    const timestampPtr = expose_binary_1.PhonemeTimestampVectorFunctions.get(phonemeTimestampsVector, i);
                    const phoneme = expose_binary_1.PhonemeTimestampFunctions.getPhoneme(timestampPtr);
                    const startTimeSec = expose_binary_1.PhonemeTimestampFunctions.getStartTimeSec(timestampPtr);
                    phonemeTimestamps.push({ phoneme, startTimeSec });
                }
            }
        }
        return phonemeTimestamps;
    }
    /**
     * Cleans up resources associated with this TTS instance.
     */
    destroy() {
        if (this.tts) {
            expose_binary_1.TTSInterfaceFunctions.delete(this.tts);
            this.tts = null;
        }
    }
}
exports.TTS = TTS;
