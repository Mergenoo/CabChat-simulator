"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorEntities = exports.Entity = void 0;
const expose_binary_1 = require("../../expose_binary");
const dictionary_rule_1 = require("./dictionary_rule");
/**
 * Class representing a named entity.
 * Provides functionality for entity definition and recognition.
 * @internal
 */
class Entity {
    /**
     * Creates a new Entity instance.
     *
     * @param external - External reference to the native entity implementation
     */
    constructor(external) {
        this.external = null;
        this.external = external;
    }
    /**
     * Gets the name/type of this entity.
     *
     * @returns Entity name or null if not set
     */
    getName() {
        if (!this.external) {
            return null;
        }
        return expose_binary_1.EntityFunctions.getName(this.external);
    }
    /**
     * Gets the dictionary rules for this entity.
     *
     * @returns Array of dictionary rules for this entity
     */
    getRules() {
        if (!this.external) {
            return [];
        }
        const rulesRef = expose_binary_1.EntityFunctions.getRules(this.external);
        return dictionary_rule_1.VectorDictionaryRules.toArray(rulesRef);
    }
    /**
     * Returns the external reference to the native entity implementation.
     *
     * @returns External reference object
     */
    getExternal() {
        return this.external;
    }
    /**
     * Cleans up resources associated with this entity.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.EntityFunctions.delete(this.external);
            this.external = null;
        }
    }
    /**
     * Creates an Entity instance from an EntityInterface.
     *
     * @param entity - Entity interface with name and rules
     * @returns New Entity instance
     */
    static createFromInterface(entity) {
        const external = expose_binary_1.EntityFunctions.new();
        if (entity.name) {
            expose_binary_1.EntityFunctions.setName(external, entity.name);
        }
        if (entity.rules) {
            const rulesVector = new dictionary_rule_1.VectorDictionaryRules(entity.rules);
            expose_binary_1.EntityFunctions.setRules(external, rulesVector.getExternal());
        }
        return new Entity(external);
    }
}
exports.Entity = Entity;
/**
 * Class for managing collections of Entity objects.
 * Provides functionality to create and manage multiple entities.
 * @internal
 */
class VectorEntities {
    /**
     * Creates a new VectorEntities collection.
     *
     * @param entities - Array of entity definitions to initialize with
     */
    constructor(entities) {
        this.external = null;
        this.entities = null;
        this.external = expose_binary_1.VectorEntityFunctions.new();
        this.entities = [];
        entities.forEach((entity) => {
            const newEntity = Entity.createFromInterface(entity);
            this.entities.push(newEntity);
            expose_binary_1.VectorEntityFunctions.pushBack(this.external, newEntity.getExternal());
        });
    }
    /**
     * Converts a native vector of entities to an array of Entity objects.
     *
     * @param external - External reference to a native entity vector
     * @returns Array of Entity objects
     */
    static toArray(external) {
        if (!external) {
            return [];
        }
        const entities = [];
        const size = expose_binary_1.VectorEntityFunctions.size(external);
        for (let i = 0; i < size; i++) {
            const entity = expose_binary_1.VectorEntityFunctions.get(external, i);
            if (entity) {
                entities.push(new Entity(entity));
            }
        }
        return entities;
    }
    /**
     * Returns the external reference to the native vector implementation.
     *
     * @returns External reference object
     */
    getExternal() {
        return this.external;
    }
    /**
     * Cleans up resources associated with this entity collection.
     */
    destroy() {
        if (this.entities) {
            this.entities.forEach((entity) => {
                entity.destroy();
            });
            this.entities = null;
        }
        if (this.external) {
            expose_binary_1.VectorEntityFunctions.delete(this.external);
            this.external = null;
        }
    }
}
exports.VectorEntities = VectorEntities;
