"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Knowledge = void 0;
const error_1 = require("../../common/error");
const helpers_1 = require("../../common/helpers");
const string_1 = require("../../common/vector/string");
const expose_binary_1 = require("../../expose_binary");
/**
 * Class for knowledge management
 * Implementation of KnowledgeInterface, provides access to knowledge management functionality
 */
class Knowledge {
    /**
     * Creates a new Knowledge instance
     * @param external Native object reference
     * @internal
     */
    constructor(external, factory) {
        this.external = external;
        this.factory = factory;
    }
    /**
     * Retrieves knowledge from the knowledge base
     * @param knowledgeGetInput Input parameters containing knowledge IDs and event history
     * @returns Array of strings containing retrieved knowledge data as individual records
     * @throws InworldError If retrieval fails
     */
    getKnowledge(knowledgeGetInput) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const idsVector = new string_1.VectorString(knowledgeGetInput.ids);
            const history = knowledgeGetInput.eventHistory;
            try {
                const result = yield expose_binary_1.KnowledgeInterfaceFunctions.getKnowledge(this.external, idsVector.getExternal(), history.getExternal());
                if (!expose_binary_1.KnowledgeVectorStatusFunctions.isOK(result)) {
                    const status = expose_binary_1.KnowledgeVectorStatusFunctions.getStatus(result);
                    throw new error_1.InworldError('Failed to get knowledge: ' + ((_a = (0, helpers_1.getStatus)(status)) === null || _a === void 0 ? void 0 : _a.status), (0, helpers_1.getStatus)(status));
                }
                return string_1.VectorString.toArray(expose_binary_1.KnowledgeVectorStatusFunctions.getValue(result));
            }
            catch (error) {
                throw new error_1.InworldError('Failed to get knowledge: ' + ((_b = error === null || error === void 0 ? void 0 : error.context) === null || _b === void 0 ? void 0 : _b.status));
            }
            finally {
                idsVector.destroy();
            }
        });
    }
    /**
     * Compiles knowledge into the knowledge base
     * @param knowledgeId ID of the knowledge to compile (must start with 'knowledge/' prefix)
     * @param recordsOrFile Records or file to be compiled
     * @returns Array of strings containing the resulting knowledge records
     * @throws InworldError If compilation fails
     */
    compileKnowledge(knowledgeId, recordsOrFile) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(recordsOrFile)) {
                return this.compileKnowledgeFromRecords(knowledgeId, recordsOrFile);
            }
            else {
                return this.compileKnowledgeFromFile(knowledgeId, recordsOrFile);
            }
        });
    }
    /**
     * Removes knowledge from the knowledge base
     * @param knowledgeId ID of the knowledge to remove (must start with 'knowledge/' prefix)
     * @throws InworldError If removal fails
     */
    removeKnowledge(knowledgeId) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield expose_binary_1.KnowledgeInterfaceFunctions.removeKnowledge(this.external, knowledgeId);
            if (!expose_binary_1.KnowledgeVectorStatusFunctions.isOK(result)) {
                const status = expose_binary_1.KnowledgeVectorStatusFunctions.getStatus(result);
                throw new error_1.InworldError('Failed to remove knowledge', (0, helpers_1.getStatus)(status));
            }
            // Note: We don't need to delete the result object as it's managed by the C++ runtime
        });
    }
    /**
     * Compiles knowledge into the knowledge base from records
     * @param knowledgeId ID of the knowledge to compile (must start with 'knowledge/' prefix)
     * @param records Records to be compiled into the knowledge base
     * @returns Array of strings containing the resulting knowledge records
     * @throws InworldError If compilation fails
     */
    compileKnowledgeFromRecords(knowledgeId, records) {
        return __awaiter(this, void 0, void 0, function* () {
            // Create vector of records
            const recordsVector = new string_1.VectorString(records);
            try {
                const result = yield expose_binary_1.KnowledgeInterfaceFunctions.compileKnowledgeFromRecords(this.external, knowledgeId, recordsVector.getExternal());
                if (!expose_binary_1.KnowledgeVectorStatusFunctions.isOK(result)) {
                    const status = expose_binary_1.KnowledgeVectorStatusFunctions.getStatus(result);
                    throw new error_1.InworldError('Failed to compile knowledge from records', (0, helpers_1.getStatus)(status));
                }
                // Get the result vector and convert to JavaScript array
                const resultVector = expose_binary_1.KnowledgeVectorStatusFunctions.getValue(result);
                try {
                    return string_1.VectorString.toArray(resultVector);
                }
                catch (_error) {
                    // Failed to access result vector, return empty array
                    return [];
                }
            }
            finally {
                recordsVector.destroy();
            }
        });
    }
    /**
     * Compiles knowledge into the knowledge base from a file
     * @param knowledgeId ID of the knowledge to compile (must start with 'knowledge/' prefix)
     * @param file File object containing the content to be compiled
     * @returns Array of strings containing the resulting knowledge records
     * @throws InworldError If compilation fails
     */
    compileKnowledgeFromFile(knowledgeId, file) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            let bytesVector;
            try {
                const buffer = Buffer.from(file.content.bytes);
                bytesVector = expose_binary_1.VectorCharFunctions.memcpyTo(buffer, buffer.length);
                const result = yield expose_binary_1.KnowledgeInterfaceFunctions.compileKnowledgeFromFile(this.external, knowledgeId, bytesVector, this.convertFileTypeToNumber(file.type));
                if (!expose_binary_1.KnowledgeVectorStatusFunctions.isOK(result)) {
                    const status = expose_binary_1.KnowledgeVectorStatusFunctions.getStatus(result);
                    const statusStr = ((_a = (0, helpers_1.getStatus)(status)) === null || _a === void 0 ? void 0 : _a.status) || 'Unknown error';
                    if (statusStr.includes('BreakIterator') || statusStr.includes('ICU')) {
                        throw new Error(`ICU error: ${statusStr}`);
                    }
                    throw new error_1.InworldError(`Failed to compile knowledge from file: ${statusStr}`, (0, helpers_1.getStatus)(status));
                }
                return string_1.VectorString.toArray(expose_binary_1.KnowledgeVectorStatusFunctions.getValue(result));
            }
            catch (error) {
                throw new error_1.InworldError(`Failed to compile knowledge from file: ${error.message}`);
            }
            finally {
                expose_binary_1.VectorCharFunctions.delete(bytesVector);
            }
        });
    }
    /**
     * Converts FileType enum string values to numeric values expected by C++ backend
     * @param fileType The FileType enum value
     * @returns Numeric representation expected by C++ (0 for PDF, 1 for TXT)
     * @private
     */
    convertFileTypeToNumber(fileType) {
        switch (fileType) {
            case 'PDF':
                return 0; // inworld_File_Type_kPdf
            case 'TXT':
                return 1; // inworld_File_Type_kTxt
            default:
                throw new error_1.InworldError(`Unknown file type: ${fileType}`);
        }
    }
    /**
     * Gets the reference to the native object
     * @returns Native object reference
     * @internal
     */
    getExternal() {
        return this.external;
    }
    /**
     * Destroys the native object
     */
    destroy() {
        if (this.external) {
            try {
                // Attempt to clean up the external resource, but handle type errors gracefully
                expose_binary_1.KnowledgeInterfaceFunctions.delete(this.external);
            }
            catch (_error) {
                // This likely means the external object was already cleaned up
                // or is being managed by the C++ runtime
            }
            this.external = null;
        }
        if (this.factory) {
            try {
                expose_binary_1.KnowledgeFactoryFunctions.delete(this.factory);
            }
            catch (_error) {
                // Factory may have already been cleaned up
            }
            this.factory = null;
        }
    }
}
exports.Knowledge = Knowledge;
