"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafetyChecker = void 0;
const error_1 = require("../../common/error");
const helpers_1 = require("../../common/helpers");
const expose_binary_1 = require("../../expose_binary");
const topics_1 = require("./topics");
/**
 * Implementation of content safety checking functionality.
 *
 * Uses native bindings to perform safety checks on text content.
 */
class SafetyChecker {
    /**
     * Creates a new instance of SafetyChecker.
     * @param embedder Text embedder for semantic understanding
     * @param config Configuration for safety checker creation
     * @returns Promise resolving to a new SafetyChecker instance
     * @throws InworldError If creation fails
     * @internal
     */
    static create(embedder, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!embedder) {
                throw new error_1.InworldError(`Error creating SafetyChecker: Embedder is required`);
            }
            if (!config) {
                throw new error_1.InworldError(`Error creating SafetyChecker: Config is required`);
            }
            if (!config.modelWeightsPath) {
                throw new error_1.InworldError(`Error creating SafetyChecker: Model weights path is required`);
            }
            const instance = new SafetyChecker(embedder);
            try {
                instance.nativeSafetyChecker =
                    yield instance.createNativeSafetyChecker(config);
                return instance;
            }
            catch (err) {
                instance.destroy();
                if (err instanceof error_1.InworldError) {
                    throw err;
                }
                throw new error_1.InworldError(`Error initializing SafetyChecker: ${err.message}`, { cause: err });
            }
        });
    }
    /**
     * @internal
     */
    constructor(embedder) {
        this.embedder = embedder;
    }
    /**
     * Creates the native safety checker instance.
     * @private
     * @param config Creation configuration
     * @returns Promise resolving to native checker instance
     * @throws InworldError If native creation fails
     */
    createNativeSafetyChecker(config) {
        return __awaiter(this, void 0, void 0, function* () {
            let factory;
            let creationConfig;
            let result;
            try {
                factory = expose_binary_1.SafetyCheckerFactoryFunctions.new();
                creationConfig = expose_binary_1.SafetyCheckerCreationConfigFunctions.new();
                expose_binary_1.SafetyCheckerCreationConfigFunctions.setModelWeightsPath(creationConfig, config.modelWeightsPath);
                result = yield expose_binary_1.SafetyCheckerFactoryFunctions.createSafetyChecker(factory, this.embedder.getExternal(), creationConfig);
                if (!expose_binary_1.StatusOrSafetyCheckerInterfaceFunctions.isOK(result)) {
                    const statusContext = (0, helpers_1.getStatus)(expose_binary_1.StatusOrSafetyCheckerInterfaceFunctions.getStatus(result));
                    throw new error_1.InworldError(`Error creating safety checker: ${statusContext}`);
                }
                return expose_binary_1.StatusOrSafetyCheckerInterfaceFunctions.getValue(result);
            }
            finally {
                if (creationConfig) {
                    expose_binary_1.SafetyCheckerCreationConfigFunctions.delete(creationConfig);
                }
                if (factory) {
                    expose_binary_1.SafetyCheckerFactoryFunctions.delete(factory);
                }
                if (result) {
                    expose_binary_1.StatusOrSafetyCheckerInterfaceFunctions.delete(result);
                }
            }
        });
    }
    /**
     * Checks the safety of input text content.
     * @param input Text content to check
     * @param config Optional runtime safety configuration
     * @returns Promise resolving to safety check results
     * @throws InworldError If check fails or input is invalid
     */
    checkSafety(input, config) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.nativeSafetyChecker) {
                    throw new error_1.InworldError(`Error checking safety: Safety checker not initialized`);
                }
                if (!input || typeof input.input !== 'string') {
                    throw new error_1.InworldError(`Error checking safety: Input must contain a non-empty string`);
                }
                let nativeConfig;
                let result;
                let response;
                try {
                    if (config) {
                        nativeConfig = this.createNativeSafetyConfig(config);
                    }
                    result = nativeConfig
                        ? yield expose_binary_1.SafetyCheckerInterfaceFunctions.checkSafetyWithConfig(this.nativeSafetyChecker, input.input, nativeConfig)
                        : yield expose_binary_1.SafetyCheckerInterfaceFunctions.checkSafety(this.nativeSafetyChecker, input.input);
                    const isOk = expose_binary_1.StatusOrCheckSafetyResponseFunctions.isOK(result);
                    if (!isOk) {
                        const status = expose_binary_1.StatusOrCheckSafetyResponseFunctions.getStatus(result);
                        const statusResult = (0, helpers_1.getStatus)(status);
                        throw new error_1.InworldError(`Error checking safety: ${statusResult}`);
                    }
                    response = expose_binary_1.StatusOrCheckSafetyResponseFunctions.getValue(result);
                    return this.convertToCheckSafetyResponse(response);
                }
                finally {
                    if (result) {
                        expose_binary_1.StatusOrCheckSafetyResponseFunctions.delete(result);
                    }
                    if (nativeConfig) {
                        expose_binary_1.SafetyConfigFunctions.delete(nativeConfig);
                    }
                }
            }
            catch (err) {
                throw new error_1.InworldError(`Error checking safety: ${err instanceof Error ? err.message : String(err)}`, {
                    cause: err,
                });
            }
        });
    }
    /**
     * Creates a native safety configuration.
     * @private
     * @param config Safety configuration
     * @returns Native configuration object
     * @throws InworldError If creation fails
     */
    createNativeSafetyConfig(config) {
        let nativeConfig;
        let nativeTopicsVector;
        const createdThresholds = [];
        try {
            nativeConfig = expose_binary_1.SafetyConfigFunctions.new();
            nativeTopicsVector = expose_binary_1.VectorTopicThresholdFunctions.new();
            for (const topic of config.forbiddenTopics) {
                const threshold = expose_binary_1.TopicThresholdFunctions.new();
                createdThresholds.push(threshold);
                expose_binary_1.TopicThresholdFunctions.setTopicName(threshold, topics_1.Topic.getTopicId(topic.topicName));
                expose_binary_1.TopicThresholdFunctions.setConfidence(threshold, topic.threshold);
                expose_binary_1.VectorTopicThresholdFunctions.pushBack(nativeTopicsVector, threshold);
            }
            expose_binary_1.SafetyConfigFunctions.setForbiddenTopics(nativeConfig, nativeTopicsVector);
            return nativeConfig;
        }
        catch (err) {
            createdThresholds.forEach((threshold) => expose_binary_1.TopicThresholdFunctions.delete(threshold));
            if (nativeConfig) {
                expose_binary_1.SafetyConfigFunctions.delete(nativeConfig);
            }
            throw err;
        }
        finally {
            if (nativeTopicsVector) {
                expose_binary_1.VectorTopicThresholdFunctions.delete(nativeTopicsVector);
            }
        }
    }
    /**
     * Converts native response to TypeScript interface.
     * @private
     * @param response Native response object
     * @returns Converted response
     */
    convertToCheckSafetyResponse(response) {
        try {
            const detectedTopics = expose_binary_1.CheckSafetyResponseFunctions.getDetectedTopics(response);
            const topics = [];
            if (detectedTopics) {
                try {
                    const topicsSize = expose_binary_1.VectorDetectedTopicFunctions.size(detectedTopics);
                    for (let i = 0; i < topicsSize; i++) {
                        const externalDetectedTopic = expose_binary_1.VectorDetectedTopicFunctions.get(detectedTopics, i);
                        if (externalDetectedTopic) {
                            try {
                                topics.push(new topics_1.DetectedTopic(externalDetectedTopic));
                            }
                            finally {
                                expose_binary_1.DetectedTopicFunctions.delete(externalDetectedTopic);
                            }
                        }
                    }
                }
                catch (err) {
                    throw new error_1.InworldError(`Error processing detected topics: ${err.message}`, { cause: err });
                }
            }
            return {
                isSafe: expose_binary_1.CheckSafetyResponseFunctions.getIsSafe(response),
                detectedTopics: topics.map((topic) => ({
                    topicName: topic.topicName,
                    confidence: topic.confidence,
                })),
            };
        }
        catch (err) {
            throw new error_1.InworldError(`Error converting safety response: ${err.message}`, {
                cause: err,
            });
        }
    }
    /**
     * Cleans up resources used by the safety checker.
     */
    destroy() {
        this.nativeSafetyChecker = null;
        // Clean up embedder if we own it
        if (this.embedder && typeof this.embedder.destroy === 'function') {
            try {
                this.embedder.destroy();
            }
            catch (err) {
                throw new error_1.InworldError(`Error destroying SafetyChecker: Error during embedder cleanup: ${err.message}`, { cause: err });
            }
            finally {
                this.embedder = null;
            }
        }
    }
}
exports.SafetyChecker = SafetyChecker;
