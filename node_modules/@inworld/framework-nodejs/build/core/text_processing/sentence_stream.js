"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SentenceStream = void 0;
const common_1 = require("../../common");
const helpers_1 = require("../../common/helpers");
const stream_1 = require("../../common/stream");
const expose_binary_1 = require("../../expose_binary");
/**
 * Class for processing text stream into sentences.
 * Provides functionality to stream text data sentence by sentence.
 */
class SentenceStream {
    /**
     * Creates a new SentenceStream instance.
     *
     * @param sentenceStream - External reference to the native sentence stream implementation
     */
    constructor(sentenceStream) {
        this.external = sentenceStream;
    }
    /**
     * Creates a new SentenceStream from an input stream.
     *
     * @param inputStream - External reference to the input stream
     * @returns Promise resolving to a new SentenceStream instance
     * @throws InworldError if sentence stream creation fails
     */
    static create(inputStream) {
        return __awaiter(this, void 0, void 0, function* () {
            let sentenceStreamInstance;
            let statusOrSentenceStream;
            try {
                statusOrSentenceStream =
                    yield expose_binary_1.SentenceStreamFunctions.create(inputStream);
                if (!expose_binary_1.StatusOrSentenceStreamFunctions.isOK(statusOrSentenceStream)) {
                    throw new common_1.InworldError('Failed to create sentence stream', (0, helpers_1.getStatus)(statusOrSentenceStream));
                }
                const sentenceStream = expose_binary_1.StatusOrSentenceStreamFunctions.getValue(statusOrSentenceStream);
                sentenceStreamInstance = new SentenceStream(sentenceStream);
            }
            finally {
                expose_binary_1.StatusOrSentenceStreamFunctions.delete(statusOrSentenceStream);
            }
            return sentenceStreamInstance;
        });
    }
    /**
     * Returns an iterator for processing the sentence stream.
     *
     * @returns Stream iterator object
     */
    getIterator() {
        return this.streamIterator(this.external);
    }
    /**
     * Cleans up resources associated with this sentence stream.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.SentenceStreamFunctions.delete(this.external);
            this.external = null;
        }
    }
    /**
     * Creates a stream iterator for the given input stream.
     *
     * @param inputStream - External reference to the input stream
     * @returns Stream iterator object
     */
    streamIterator(inputStream) {
        const stringStream = new stream_1.TextStream(inputStream);
        return {
            getStream() {
                return stringStream.get();
            },
            next() {
                return __awaiter(this, void 0, void 0, function* () {
                    return stringStream.next();
                });
            },
        };
    }
}
exports.SentenceStream = SentenceStream;
