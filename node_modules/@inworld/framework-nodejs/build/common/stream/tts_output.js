"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TTSOutputStream = void 0;
const expose_binary_1 = require("../../expose_binary");
const data_types_1 = require("../../graph/data_types");
const error_1 = require("../error");
const helpers_1 = require("../helpers");
/**
 * Class for handling string-based streams.
 * Provides functionality to read text data from native stream implementations.
 * @internal
 */
class TTSOutputStream {
    /**
     * Creates a new TTSOutputStream instance.
     *
     * @param stream - External reference to the native stream implementation
     */
    constructor(stream) {
        this.stream = stream;
    }
    /**
     * Asynchronously reads the next item from the stream.
     *
     * @returns Promise resolving to a result object with text content or done flag
     * @throws InworldError if reading from the stream fails
     */
    next() {
        return __awaiter(this, void 0, void 0, function* () {
            while (expose_binary_1.TTSOutputFunctions.streamHasNext(this.stream)) {
                let externalAudio;
                try {
                    const streamRead = expose_binary_1.TTSOutputFunctions.streamRead(this.stream);
                    if (expose_binary_1.TTSOutputFunctions.isOK(streamRead)) {
                        const value = expose_binary_1.TTSOutputFunctions.getValue(streamRead);
                        externalAudio = expose_binary_1.TTSOutputFunctions.getAudio(value);
                        return {
                            audio: data_types_1.AudioData.fromExternal(externalAudio).getData(),
                            text: expose_binary_1.TTSOutputFunctions.getText(value),
                            done: false,
                        };
                    }
                    else {
                        throw new error_1.InworldError('Failed to get TTS output', (0, helpers_1.getStatus)(streamRead));
                    }
                }
                finally {
                    if (externalAudio) {
                        expose_binary_1.TTSOutputFunctions.audioDelete(externalAudio);
                    }
                }
            }
            return { done: true };
        });
    }
    /**
     * Creates a new TTSOutputStream instance from an external reference.
     *
     * @param stream - External reference to the native stream implementation
     * @returns A new TTSOutputStream instance
     * @internal
     */
    static fromExternal(stream) {
        const streamData = expose_binary_1.TTSOutputFunctions.getStream(stream);
        return new TTSOutputStream(streamData);
    }
}
exports.TTSOutputStream = TTSOutputStream;
