"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextStream = void 0;
const expose_binary_1 = require("../../expose_binary");
const error_1 = require("../error");
const helpers_1 = require("../helpers");
/**
 * Class for handling string-based streams.
 * Provides functionality to read text data from native stream implementations.
 * @internal
 */
class TextStream {
    /**
     * Creates a new TextStream instance.
     *
     * @param stream - External reference to the native stream implementation
     * @param onDestroy - Optional callback to execute when stream is consumed
     */
    constructor(stream, onDestroy) {
        this.stream = stream;
        this.onDestroy = onDestroy;
    }
    /**
     * Returns the external reference to the native stream implementation.
     *
     * @returns External reference object
     */
    get() {
        return this.stream;
    }
    /**
     * Asynchronously reads the next item from the stream.
     *
     * @returns Promise resolving to a result object with text content or done flag
     * @throws InworldError if reading from the stream fails
     */
    next() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            while (expose_binary_1.InputStreamFunctions.hasNext(this.stream)) {
                let inputStatus = yield expose_binary_1.InputStreamFunctions.read(this.stream);
                if (!expose_binary_1.InputStreamFunctions.isOK(inputStatus)) {
                    (_a = this.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
                    throw new error_1.InworldError('Failed to read input stream', (0, helpers_1.getStatus)(inputStatus));
                }
                else {
                    return {
                        text: expose_binary_1.InworldStringFunctions.get(inputStatus),
                        done: false,
                    };
                }
            }
            (_b = this.onDestroy) === null || _b === void 0 ? void 0 : _b.call(this);
            return { done: true };
        });
    }
    /**
     * Creates a new TextStream instance from an external reference.
     *
     * @param external - External reference to the native stream implementation
     * @returns A new TextStream instance
     * @internal
     */
    static fromExternal(external) {
        const stream = expose_binary_1.StreamStringFunctions.toStream(external);
        const streamData = expose_binary_1.StreamStringFunctions.getStream(stream);
        return new TextStream(streamData, () => {
            expose_binary_1.StreamStringFunctions.delete(stream);
            expose_binary_1.StreamStringFunctions.deleteStream(streamData);
        });
    }
}
exports.TextStream = TextStream;
