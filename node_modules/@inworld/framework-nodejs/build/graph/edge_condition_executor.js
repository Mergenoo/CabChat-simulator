"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeConditionExecutor = void 0;
const uuid_1 = require("uuid");
const koffi = require("koffi");
const common_1 = require("../common");
const stream_1 = require("../common/stream");
const expose_binary_1 = require("../expose_binary");
const data_types_1 = require("./data_types");
/**
 * Currently, async functions cannot be executed directly in graph nodes.
 * We need to migrate to Node-API to handle async functions natively without deasync.
 *
 * Using deasync@1.0.4 specifically because newer versions have type definition issues
 * in index.d.ts that break yarn build, though ts-node still works.
 * TODO: Update once Node-API migration is complete.
 */
const deasync = require("@kaciras/deasync");
/**
 * EdgeConditionExecutor class for implementing conditional edge logic.
 * Allows edges to be traversed only when specific conditions are met.
 */
class EdgeConditionExecutor {
    /**
     * Creates a new EdgeConditionExecutor with a condition callback.
     *
     * @param condition - Function that determines if the edge should be traversed
     */
    constructor(condition) {
        this.external = null;
        this.externalCallback = null;
        const ExternalConditionCallback = koffi.proto(`ExternalConditionCallback-${(0, uuid_1.v4)()}`, 'void', ['int']);
        const callback = (executionId) => {
            let result = false;
            try {
                const input = expose_binary_1.EdgeConditionExecutorFunctions.getInput(executionId);
                const inputData = this.getInputData(input);
                expose_binary_1.EdgeConditionExecutorFunctions.setOutput(executionId, deasync.awaitSync(condition(inputData)));
            }
            catch (_error) {
                // On error, don't traverse the edge
                expose_binary_1.EdgeConditionExecutorFunctions.setOutput(executionId, result);
            }
        };
        const externalCondition = koffi.register((executionId) => {
            callback(executionId);
        }, koffi.pointer(ExternalConditionCallback));
        this.external = expose_binary_1.EdgeConditionExecutorFunctions.new(externalCondition);
        this.externalCallback = externalCondition;
    }
    /**
     * Gets the external reference for use with C++ bindings.
     *
     * @returns External reference pointer
     */
    getExternal() {
        return this.external;
    }
    /**
     * Cleans up resources associated with this executor.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.EdgeConditionExecutorFunctions.delete(this.external);
            this.external = null;
        }
        if (this.externalCallback) {
            koffi.unregister(this.externalCallback);
            this.externalCallback = null;
        }
    }
    getInputData(input) {
        try {
            // Text stream
            const textStream = expose_binary_1.StreamStringFunctions.toStream(input);
            if (textStream) {
                return stream_1.TextStream.fromExternal(textStream);
            }
            // TTS stream
            const ttsStream = expose_binary_1.TTSOutputFunctions.toStream(input);
            if (ttsStream) {
                return stream_1.TTSOutputStream.fromExternal(ttsStream);
            }
            // Knowledge records
            const records = data_types_1.KnowledgeRecords.fromExternal(input).getRecords();
            if (records) {
                return records;
            }
            // Plain text
            const text = expose_binary_1.BaseDataFunctions.asText(input) || input;
            if (text) {
                return data_types_1.TextData.fromExternal(text).getText();
            }
        }
        catch (error) {
            throw new common_1.InworldError('Invalid input data for edge condition executor', error);
        }
    }
}
exports.EdgeConditionExecutor = EdgeConditionExecutor;
