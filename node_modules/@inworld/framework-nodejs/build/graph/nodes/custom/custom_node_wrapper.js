"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomNodeWrapper = void 0;
const expose_binary_1 = require("../../../expose_binary");
/**
 * Currently, async functions cannot be executed directly in graph nodes.
 * We need to migrate to Node-API to handle async functions natively without deasync.
 *
 * Using deasync@1.0.4 specifically because newer versions have type definition issues
 * in index.d.ts that break yarn build, though ts-node still works.
 * TODO: Update once Node-API migration is complete.
 */
const deasync = require("@kaciras/deasync");
const koffi = require("koffi");
const uuid_1 = require("uuid");
const stream_1 = require("../../../common/stream");
const types_1 = require("../../../common/types");
const data_types_1 = require("../../data_types");
const node_1 = require("../node");
const error_1 = require("./error");
/**
 * Wrapper class that integrates custom node logic with the graph framework.
 * Bridges between JavaScript code and the native graph implementation.
 */
class CustomNodeWrapper extends node_1.Node {
    /**
     * Creates a new CustomNodeWrapper instance.
     *
     * @param props - Custom node wrapper creation properties
     * @throws InworldError if result type is not supported
     * @internal
     */
    constructor({ id, process, inputTypes, outputType }) {
        const ExternalProcessCallback = koffi.proto(`ExternalProcessCallback-${id}-${(0, uuid_1.v4)()}`, 'void', ['void *', 'int']);
        const callback = (executionId) => {
            const externalInputs = expose_binary_1.CustomNodeThreadedProcessExecutorFunctions.getInputs(executionId);
            const inputs = data_types_1.VectorBaseData.toArray(externalInputs);
            if (!(inputs === null || inputs === void 0 ? void 0 : inputs.length)) {
                throw new error_1.ExternalProcessError(`No inputs provided for custom node ${id}`, error_1.ExternalProcessStatusCode.InvalidArgument);
            }
            if (inputs.length !== this.inputTypes.length) {
                throw new error_1.ExternalProcessError(`Invalid number of inputs for custom node ${id}`, error_1.ExternalProcessStatusCode.InvalidArgument);
            }
            for (let i = 0; i < inputs.length; i++) {
                inputs[i] = this.fromExternal(inputs[i], this.inputTypes[i]);
            }
            const output = this.toExternal(deasync.awaitSync(process(inputs)));
            if (output instanceof data_types_1.BaseData) {
                const outputPtr = expose_binary_1.StatusOrBaseDataFunctions.newFromBaseData(output.getExternal());
                this.setResult(executionId, outputPtr);
                expose_binary_1.StatusOrBaseDataFunctions.delete(outputPtr);
            }
        };
        const externalProcess = koffi.register((_, executionId) => {
            try {
                callback(executionId);
            }
            catch (e) {
                let error = e;
                if (!(error instanceof error_1.ExternalProcessError)) {
                    error = new error_1.ExternalProcessError(error.message, error_1.ExternalProcessStatusCode.Unknown);
                }
                this.setResult(executionId, expose_binary_1.StatusOrBaseDataFunctions.newFromStatus(error.getExternal()));
            }
        }, koffi.pointer(ExternalProcessCallback));
        const processExecutor = expose_binary_1.CustomNodeThreadedProcessExecutorFunctions.new(id, externalProcess);
        super(id, expose_binary_1.CustomNodeWrapperFunctions.new(id, processExecutor));
        expose_binary_1.CustomNodeThreadedProcessExecutorFunctions.delete(processExecutor);
        this.externalProcess = externalProcess;
        this.inputTypes = inputTypes;
        this.outputType = outputType;
    }
    /**
     * Cleans up resources associated with this custom node wrapper.
     */
    destroy() {
        if (this.getExternal()) {
            expose_binary_1.CustomNodeWrapperFunctions.delete(this.getExternal());
            this.external = null;
        }
        if (this.externalProcess) {
            koffi.unregister(this.externalProcess);
            this.externalProcess = null;
        }
    }
    fromExternal(input, type) {
        if (type === types_1.CustomInputDataType.JSON) {
            try {
                return JSON.parse(data_types_1.TextData.fromExternal(input).getText());
            }
            catch (error) {
                throw new error_1.ExternalProcessError(`Error parsing JSON: ${error}`, error_1.ExternalProcessStatusCode.InvalidArgument);
            }
        }
        else if (type === types_1.CustomInputDataType.TEXT) {
            return data_types_1.TextData.fromExternal(input).getText();
        }
        else if (type === types_1.CustomInputDataType.TEXT_STREAM) {
            return stream_1.TextStream.fromExternal(input);
        }
        else if (type === types_1.CustomInputDataType.TTS_STREAM) {
            return stream_1.TTSOutputStream.fromExternal(input);
        }
        else if (type === types_1.CustomInputDataType.KNOWLEDGE_RECORDS) {
            return data_types_1.KnowledgeRecords.fromExternal(input).getRecords();
        }
        throw new error_1.ExternalProcessError(`Unsupported input type: ${type}`, error_1.ExternalProcessStatusCode.InvalidArgument);
    }
    toExternal(output) {
        if (this.outputType === types_1.CustomOutputDataType.TEXT) {
            return new data_types_1.TextData(output);
        }
        else if (this.outputType === types_1.CustomOutputDataType.JSON) {
            return new data_types_1.TextData(JSON.stringify(output));
        }
        else if (this.outputType === types_1.CustomOutputDataType.CHAT_MESSAGES) {
            return new data_types_1.ChatMessages(output);
        }
        else if (this.outputType === types_1.CustomOutputDataType.AUDIO) {
            return new data_types_1.AudioData(output);
        }
        throw new error_1.ExternalProcessError(`Unsupported output type: ${this.outputType}`, error_1.ExternalProcessStatusCode.InvalidArgument);
    }
    setResult(executionId, output) {
        expose_binary_1.CustomNodeThreadedProcessExecutorFunctions.setOutput(executionId, output);
    }
}
exports.CustomNodeWrapper = CustomNodeWrapper;
