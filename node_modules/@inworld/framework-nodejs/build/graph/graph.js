"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graph = void 0;
const common_1 = require("../common");
const helpers_1 = require("../common/helpers");
const expose_binary_1 = require("../expose_binary");
const data_types_1 = require("./data_types");
const edge_condition_executor_1 = require("./edge_condition_executor");
const graph_executor_1 = require("./graph_executor");
const graph_output_stream_1 = require("./graph_output_stream");
/**
 * Class representing a computational graph.
 * Provides functionality to construct and manage processing pipelines.
 */
class Graph {
    /**
     * Creates a new Graph instance with the specified ID.
     *
     * @param id - Unique identifier for the graph
     */
    constructor(id) {
        this.external = null;
        this.compiled = null;
        this.executor = null;
        this.conditionExecutors = [];
        this.external = expose_binary_1.GraphFunctions.new(id);
    }
    /**
     * Adds a node to the graph.
     *
     * @param node - Node to add to the graph
     */
    addNode(node) {
        expose_binary_1.GraphFunctions.addNode(this.external, node.getExternal());
    }
    /**
     * Creates an edge between two nodes in the graph.
     *
     * @param src - Source node
     * @param dst - Destination node
     * @param options - Edge options
     */
    addEdge(src, dst, options = {}) {
        const edge = expose_binary_1.GraphFunctions.createEdge(this.external, src.getExternal(), dst.getExternal());
        if (options.condition) {
            const conditionExecutor = new edge_condition_executor_1.EdgeConditionExecutor(options.condition);
            expose_binary_1.EdgeWrapperFunctions.setCondition(edge, conditionExecutor.getExternal());
            this.conditionExecutors.push(conditionExecutor);
        }
        if (options.optional) {
            expose_binary_1.EdgeWrapperFunctions.setToOptional(edge);
        }
        expose_binary_1.EdgeWrapperFunctions.build(edge);
    }
    /**
     * Sets a node as the starting point for graph execution.
     *
     * @param node - Node to set as the start node
     */
    setStartNode(node) {
        expose_binary_1.GraphFunctions.setAsStart(this.external, node.getExternal());
    }
    /**
     * Sets a node as the end point for graph execution.
     *
     * @param node - Node to set as the end node
     */
    setEndNode(node) {
        expose_binary_1.GraphFunctions.setAsEnd(this.external, node.getExternal());
    }
    /**
     * Compiles the graph and returns a reference to the compiled graph.
     * The graph must be compiled before it can be executed.
     *
     * @returns External reference to the compiled graph
     */
    compile() {
        this.compiled = expose_binary_1.GraphFunctions.compileAndReturnRaw(this.external);
    }
    /**
     * Executes the compiled graph.
     *
     * @param input - Input data to execute the graph
     * @param executionId - Unique identifier for this execution
     * @returns Promise resolving to the execution output stream
     */
    execute(input, executionId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.compiled) {
                this.compile();
            }
            if (!this.executor) {
                this.executor = new graph_executor_1.GraphExecutor(this.compiled);
            }
            const data = this.convertInputToData(input);
            const index = yield this.executor.execute(data, executionId);
            this.executor.start();
            return new graph_output_stream_1.GraphOutputStream(this.executor, index, data);
        });
    }
    /**
     * Closes a specific execution.
     *
     * @param outputStream - Output stream of the execution to close
     */
    closeExecution(outputStream) {
        this.executor.closeExecution(outputStream.index);
    }
    /**
     * Cleans up all active executions.
     */
    cleanupAllExecutions() {
        this.executor.cleanupAllExecutions();
    }
    /**
     * Stops the graph executor.
     */
    stopExecutor() {
        this.executor.stop();
    }
    /**
     * Visualizes the compiled graph and saves the visualization to a file.
     *
     * @param path - File path where the visualization will be saved
     */
    visualize(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.compiled) {
                this.compile();
            }
            const status = yield expose_binary_1.GraphFunctions.visualize(this.compiled, path);
            if (!expose_binary_1.StatusFunctions.isOK(status)) {
                throw new common_1.InworldError('Failed to visualize graph', (0, helpers_1.getStatus)(status));
            }
        });
    }
    /**
     * Cleans up resources associated with this graph.
     */
    destroy() {
        if (this.external) {
            expose_binary_1.GraphFunctions.delete(this.external);
            this.external = null;
        }
        if (this.executor) {
            this.executor.destroy();
            this.executor = null;
        }
        this.conditionExecutors.forEach((executor) => {
            executor.destroy();
        });
        this.conditionExecutors = [];
    }
    convertInputToData(input) {
        if (Array.isArray(input)) {
            return new data_types_1.ChatMessages(input);
        }
        else if (typeof input === 'object' &&
            (input === null || input === void 0 ? void 0 : input.hasOwnProperty('data')) &&
            (input === null || input === void 0 ? void 0 : input.hasOwnProperty('sampleRate'))) {
            return new data_types_1.AudioData({
                data: input.data,
                sampleRate: input.sampleRate,
            });
        }
        else if (typeof input === 'string') {
            return new data_types_1.TextData(input);
        }
        else {
            throw new common_1.InworldError('Invalid input type');
        }
    }
}
exports.Graph = Graph;
